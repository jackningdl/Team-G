contract Test{
  uint a;

  function func1() external{
  }

  funciton func2(){
    this.func1;
  }
}

pragma solidity ^0.4.21;

contract owned {
  address owner; // 这个默认可适度是internal

  function owned(){
    owner = msg.sender;
  }
}

contract Parent is owned{  // 这句话的意思是，parent是继承了owned这个合约的
  uint x;

  function Parent(uint _x){
    x = _x;
  }

  function parentFunction1() internal{
    if(msg.sender == owner) selfdestruct(owner);
  }

  function parentFunction2() public{}
  function parentFunction3() external{}
  function parentFunction4() private{}
}

contract Child is Parent{
  uint y;
  function Child(uint _y) Parent(_y* _y){
    y = _y;
  }

  function child(){
    parentFunction1();
    parentFunction2();
    this.parentFunction3();
    //不能调用functionParent4，因为private 对继承类不可见
  }
}

contract Child2 is Parent(666){
  uint y;
  function Child(uint _y){
    y = _y;
  }

  function child(){
    parentFunction1();
    parentFunction2();
    this.parentFunction3();
    //不能调用functionParent4，因为private 对继承类不可见
  }
}



//抽象合约：

pragma solidity ^0.4.0;

像这样没有定义函数的合约就叫抽象合约
contract Parent{
  function someFun() returns (uint){
}

contract Child{
  function someFun() returns(uint){
    return 1;
  }
}


//多继承

contract Base1 {
  function func1(){}
}

contract Base2 {
  function func2(){}
}

contract Final is Base1, Base2{
}



//重名函数
contract Base1 {
  function func1(){}
}

contract Base2 {
  function func1(){}
}

contract Final is Base1, Base2{
}
contract test{
  Final f = new Final();
  f.func1(); // base2 的function被调用
}

// super

contract foundation{
  function func1{
    // do stuff}
}
contract Base1 is foundation{
  function func1(){ super.func1()};
}
contract Base2 is foundation{
  function func1(){ super.func2()};
}
contract Final is Base1, Base2{
}
contract test{
  Final f = new Final();
  f.func1(); // base2 的function被调用
}




pragma solidity ^0.4.18;

/**
 * @title SafeMath
 * @dev Math operations with safety checks that throw on error
 */
library SafeMath {

  /**
  * @dev Multiplies two numbers, throws on overflow.
  */
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  /**
  * @dev Integer division of two numbers, truncating the quotient.
  */
  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automatically throws when dividing by 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // There is no case in which this doesn't hold
    return c;
  }

  /**
  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).
  */
  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  /**
  * @dev Adds two numbers, throws on overflow.
  */
  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}






Pragma solidity ^0.4.0;

import ‘./SafeMath.sol’
contract Test {
  using SafeMath for uint8;

  uint8 public a = 101;

  function set() public{
    a = SafeMath.sub(a, 100);
    // 也就是说，用using以后，就将 sub 这个函数里面的第一个参数，变成了这里的 调用者 a
  }

}
